/*$file${HSMs::../src::AlarmClock_HSM.cpp} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*
* Model: AlarmClock.qm
* File:  ${HSMs::../src::AlarmClock_HSM.cpp}
*
* This code has been generated by QM 5.2.2 <www.state-machine.com/qm>.
* DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
*
* SPDX-License-Identifier: GPL-3.0-or-later
*
* This generated code is open source software: you can redistribute it under
* the terms of the GNU General Public License as published by the Free
* Software Foundation.
*
* This code is distributed in the hope that it will be useful, but WITHOUT
* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
* more details.
*
* NOTE:
* Alternatively, this generated code may be distributed under the terms
* of Quantum Leaps commercial licenses, which expressly supersede the GNU
* General Public License and are specifically designed for licensees
* interested in retaining the proprietary status of their code.
*
* Contact information:
* <www.state-machine.com/licensing>
* <info@state-machine.com>
*/
/*$endhead${HSMs::../src::AlarmClock_HSM.cpp} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
#include <Arduino.h>
#include "qpn.h"
#include "lcd.h"
#include "AlarmClock_HSM.h"

/*$declare${HSMs::Alarm_Clock} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/

/*${HSMs::Alarm_Clock} .....................................................*/
typedef struct Alarm_Clock {
/* protected: */
    QHsm super;

/* private: */
    uint32_t temp_time;
    uint32_t alarm_time;
    uint32_t alarm_status;
    uint32_t time_mode;
    uint8_t temp_format;
    uint8_t temp_digit;
    uint8_t timeout;
    uint16_t alarm_timeout;
    uint8_t curr_setting;

/* private state histories */
    QStateHandler hist_CLOCK;
} Alarm_Clock;

/* public: */
static uint32_t Alarm_Clock_get_curr_time(void);
static void Alarm_Clock_update_curr_time(void);
static void Alarm_Clock_set_curr_time(uint32_t new_curr_time);
static void Alarm_Clock_display_curr_time(Alarm_Clock * const me,
    uint8_t row,
    uint8_t col);
static void Alarm_Clock_display_clock_setting_time(Alarm_Clock * const me,
    uint8_t row,
    uint8_t col);
extern Alarm_Clock Alarm_Clock_obj;
extern uint32_t Alarm_Clock_curr_time;

/* protected: */
static QState Alarm_Clock_initial(Alarm_Clock * const me);
static QState Alarm_Clock_CLOCK(Alarm_Clock * const me);
static QState Alarm_Clock_Setting(Alarm_Clock * const me);
static QState Alarm_Clock_Alarm_Setting(Alarm_Clock * const me);
static QState Alarm_Clock_ASet_sec_d1(Alarm_Clock * const me);
static QState Alarm_Clock_ASet_hour_d1(Alarm_Clock * const me);
static QState Alarm_Clock_ASet_sec_d2(Alarm_Clock * const me);
static QState Alarm_Clock_ASet_error(Alarm_Clock * const me);
static QState Alarm_Clock_AS_err_on(Alarm_Clock * const me);
static QState Alarm_Clock_AS_err_off(Alarm_Clock * const me);
static QState Alarm_Clock_ASet_format(Alarm_Clock * const me);
static QState Alarm_Clock_ASet_hour_d2(Alarm_Clock * const me);
static QState Alarm_Clock_ASet_min_d1(Alarm_Clock * const me);
static QState Alarm_Clock_ASet_min_d2(Alarm_Clock * const me);
static QState Alarm_Clock_Alarm_OnOff(Alarm_Clock * const me);
static QState Alarm_Clock_Clock_Setting(Alarm_Clock * const me);
static QState Alarm_Clock_ClkSet_hour_d2(Alarm_Clock * const me);
static QState Alarm_Clock_ClkSet_min_d2(Alarm_Clock * const me);
static QState Alarm_Clock_ClkSet_format(Alarm_Clock * const me);
static QState Alarm_Clock_ClkSet_sec_d2(Alarm_Clock * const me);
static QState Alarm_Clock_ClkSet_hour_d1(Alarm_Clock * const me);
static QState Alarm_Clock_ClkSet_min_d1(Alarm_Clock * const me);
static QState Alarm_Clock_ClkSet_error(Alarm_Clock * const me);
static QState Alarm_Clock_err_on(Alarm_Clock * const me);
static QState Alarm_Clock_err_off(Alarm_Clock * const me);
static QState Alarm_Clock_ClkSet_sec_d1(Alarm_Clock * const me);
static QState Alarm_Clock_Ticking(Alarm_Clock * const me);
static QState Alarm_Clock_Alarm_Reminder(Alarm_Clock * const me);
static QState Alarm_Clock_Alarm_Msg_ON(Alarm_Clock * const me);
static QState Alarm_Clock_Alarm_Msg_OFF(Alarm_Clock * const me);
/*$enddecl${HSMs::Alarm_Clock} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
/*$skip${QP_VERSION} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/* Check for the minimum required QP version */
#if (QP_VERSION < 690U) || (QP_VERSION != ((QP_RELEASE^4294967295U) % 0x3E8U))
#error qpn version 6.9.0 or higher required
#endif
/*$endskip${QP_VERSION} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/

/*$define${HSMs::super_AlarmClock} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/

/*${HSMs::super_AlarmClock} ................................................*/
QHsm *const super_AlarmClock = &Alarm_Clock_obj.super;
/*$enddef${HSMs::super_AlarmClock} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/

//Prototypes of helper functions
String get_am_or_pm(uint32_t time24h);
void display_write(String str_, uint8_t r, uint8_t c);
String integertime_to_string(uint32_t time_);
uint32_t convert_12hformat_to_24h(uint32_t time12h, time_format_t ampm);
uint32_t convert_24hformat_to_12h(uint32_t time24h);
void display_cursor_on_blinkon(void);
void display_cursor_off_blinkoff();
void display_set_cursor(uint8_t r, uint8_t c);
void display_clear(void);
bool is_time_set_error(uint32_t time_, time_format_t format);
void display_erase_block(uint8_t row,uint8_t col_start,uint8_t col_stop);

/*$define${HSMs::Alarm_Clock_ctor} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/

/*${HSMs::Alarm_Clock_ctor} ................................................*/
void Alarm_Clock_ctor(void) {
    QHsm_ctor(&Alarm_Clock_obj.super, Q_STATE_CAST(&Alarm_Clock_initial));
}
/*$enddef${HSMs::Alarm_Clock_ctor} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
/*$define${HSMs::Alarm_Clock} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/

/*${HSMs::Alarm_Clock} .....................................................*/
Alarm_Clock Alarm_Clock_obj;
uint32_t Alarm_Clock_curr_time;

/*${HSMs::Alarm_Clock::get_curr_time} ......................................*/
static uint32_t Alarm_Clock_get_curr_time(void) {
    // We are disable the ISR and get the current time
    uint8_t saved_sreg = SREG; //Save the status of SREG
    uint32_t temp;
    cli(); //This command disable the interrupt
    temp = Alarm_Clock_curr_time; //Setting the new value
    SREG = saved_sreg;
    return temp;
}

/*${HSMs::Alarm_Clock::update_curr_time} ...................................*/
static void Alarm_Clock_update_curr_time(void) {
    if(++Alarm_Clock_curr_time == MAX_TIME){
        Alarm_Clock_curr_time = 0;
    }
}

/*${HSMs::Alarm_Clock::set_curr_time} ......................................*/
static void Alarm_Clock_set_curr_time(uint32_t new_curr_time) {
    // We are disable the ISR and set the current time
    uint8_t save_sreg = SREG; //Save the status of SREG
    cli(); //This command disable the interrupt
    TCCR1B &= ~(0x7U); //Stop the TIMER1
    TCNT1 = 0U;// Make counter register zero.
    Alarm_Clock_curr_time = new_curr_time; //Setting the new value
    TCCR1B |= 0x4U;//Provide clock source with prescaler clk/256
    SREG = save_sreg;


}

/*${HSMs::Alarm_Clock::display_curr_time} ..................................*/
static void Alarm_Clock_display_curr_time(Alarm_Clock * const me,
    uint8_t row,
    uint8_t col)
{
    /*
     * Convert the current time into string and displays it depending upon the time mode
     * param1: 'me' pointer
     * param2 : row number of the LCD
     * param3: column number of the LCD
     */
    String time_as_string; // Create String class object
    uint32_t time_;

    uint32_t time24h = Alarm_Clock_get_curr_time();
    uint8_t ss = time24h % 10U;       //extract sub-second to append later
    time24h /= 10; //convert the time to number of seconds

    time_ = (me->time_mode == MODE_24H)?time24h:convert_24hformat_to_12h(time24h);
    time_as_string = integertime_to_string(time_); //hh:mm:ss
    time_as_string.concat('.'); //concat is just a member of String object
    time_as_string.concat(ss);

    /*if mode is 12H , concatenate  am/pm information */
    if(me->time_mode == MODE_12H){
        time_as_string.concat(' ');
        time_as_string.concat(get_am_or_pm(time24h));
    }

    display_write(time_as_string,row,col); //Display in the LCD
}

/*${HSMs::Alarm_Clock::display_clock_setting_time} .........................*/
static void Alarm_Clock_display_clock_setting_time(Alarm_Clock * const me,
    uint8_t row,
    uint8_t col)
{
    /*
     * Convert the current time into string and displays it depending upon the time mode
     * param1: 'me' pointer
     * param2 : row number of the LCD
     * param3: column number of the LCD
     */
    String time_as_string;

    time_as_string = integertime_to_string(me->temp_time); //hh:mm:ss

    /*concatenate(combine)  am/pm information */
    if(me->temp_format != FORMAT_24H){
        time_as_string.concat(' ');
        if(me->temp_format == FORMAT_AM)
            time_as_string.concat("AM");
        else
            time_as_string.concat("PM");
    }

    display_write(time_as_string,row,col);
}

/*${HSMs::Alarm_Clock::SM} .................................................*/
static QState Alarm_Clock_initial(Alarm_Clock * const me) {
    /*${HSMs::Alarm_Clock::SM::initial} */
    Alarm_Clock_set_curr_time(INITIAL_CURR_TIME);
    me->alarm_time = INITIAL_ALARM_TIME;
    me->alarm_status = ALARM_OFF;
    me->time_mode = MODE_12H;

    /* state history attributes */
    /* state history attributes */
    me->hist_CLOCK = Q_STATE_CAST(&Alarm_Clock_Ticking);
    return Q_TRAN(&Alarm_Clock_Ticking);
}

/*${HSMs::Alarm_Clock::SM::CLOCK} ..........................................*/
static QState Alarm_Clock_CLOCK(Alarm_Clock * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*${HSMs::Alarm_Clock::SM::CLOCK} */
        case Q_EXIT_SIG: {
            /* save deep history */
            me->hist_CLOCK = QHsm_state(me);
            status_ = Q_HANDLED();
            break;
        }
        /*${HSMs::Alarm_Clock::SM::CLOCK::ALARM} */
        case ALARM_SIG: {
            /*${HSMs::Alarm_Clock::SM::CLOCK::ALARM::[me->alarm_status==ALARM_ON&&Ala~} */
            if (me->alarm_status == ALARM_ON && Alarm_Clock_get_curr_time()/10 == me->alarm_time) {
                //Comment for guard lines : We are checking if alarm status ON
                //And current time(diveded by 10 to get in terms of second) is equal to user setting alarm time
                status_ = Q_TRAN(&Alarm_Clock_Alarm_Reminder);
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

/*${HSMs::Alarm_Clock::SM::CLOCK::Setting} .................................*/
static QState Alarm_Clock_Setting(Alarm_Clock * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*${HSMs::Alarm_Clock::SM::CLOCK::Setting} */
        case Q_EXIT_SIG: {
            display_clear();
            display_cursor_off_blinkoff();
            status_ = Q_HANDLED();
            break;
        }
        /*${HSMs::Alarm_Clock::SM::CLOCK::Setting::CANCEL} */
        case CANCEL_SIG: {
            status_ = Q_TRAN(&Alarm_Clock_Ticking);
            break;
        }
        /*${HSMs::Alarm_Clock::SM::CLOCK::Setting::OK} */
        case OK_SIG: {
            status_ = Q_TRAN(&Alarm_Clock_Ticking);
            break;
        }
        default: {
            status_ = Q_SUPER(&Alarm_Clock_CLOCK);
            break;
        }
    }
    return status_;
}

/*${HSMs::Alarm_Clock::SM::CLOCK::Setting::Alarm_Setting} ..................*/
static QState Alarm_Clock_Alarm_Setting(Alarm_Clock * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*${HSMs::Alarm_Clock::SM::CLOCK::Setting::Alarm_Setting} */
        case Q_ENTRY_SIG: {
            Alarm_Clock_display_clock_setting_time(me, CLOCK_SETTING_TIME_ROW, CLOCK_SETTING_TIME_COL);
            display_cursor_on_blinkon();
            status_ = Q_HANDLED();
            break;
        }
        /*${HSMs::Alarm_Clock::SM::CLOCK::Setting::Alarm_Setting::initial} */
        case Q_INIT_SIG: {
            status_ = Q_TRAN(&Alarm_Clock_ASet_hour_d1);
            break;
        }
        /*${HSMs::Alarm_Clock::SM::CLOCK::Setting::Alarm_Setting::OK} */
        case OK_SIG: {
            me->alarm_status = me->temp_digit; //We copied the user selection whether 0(off) or 1(on) to the alarm status
            if(me->temp_format != FORMAT_24H){
                me->temp_time = convert_12hformat_to_24h( me->temp_time,(time_format_t)me->temp_format);
            }
            /*${HSMs::Alarm_Clock::SM::CLOCK::Setting::Alarm_Setting::OK::[0]} */
            if (0) {
                status_ = Q_HANDLED();
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        /*${HSMs::Alarm_Clock::SM::CLOCK::Setting::Alarm_Setting::TICK} */
        case TICK_SIG: {
            Alarm_Clock_display_curr_time(me,ALARM_SETTING_CURR_TIME_ROW,ALARM_SETTING_CURR_TIME_COL);

            if( QHsm_state(me) != Q_STATE_CAST(&Alarm_Clock_Alarm_OnOff)) // If its not in the alarmonOff state
                Alarm_Clock_display_clock_setting_time(me,CLOCK_SETTING_TIME_ROW,CLOCK_SETTING_TIME_COL);

            //We are just checking which state we are and according to that set the cursor!!
            if( QHsm_state(me) == Q_STATE_CAST(&Alarm_Clock_ASet_hour_d1)) //This macro(QHsm_state(me)) helps to obtain current active state
                display_set_cursor(CLOCK_SETTING_TIME_ROW,CLOCK_SETTING_TIME_HOUR_D1_COL); //It is a  function pointer
            else if( QHsm_state(me) == Q_STATE_CAST(&Alarm_Clock_ASet_hour_d2))
                display_set_cursor(CLOCK_SETTING_TIME_ROW,CLOCK_SETTING_TIME_HOUR_D2_COL);
            else if( QHsm_state(me) == Q_STATE_CAST(&Alarm_Clock_ASet_min_d1))
                display_set_cursor(CLOCK_SETTING_TIME_ROW,CLOCK_SETTING_TIME_MIN_D1_COL);
            else if( QHsm_state(me) == Q_STATE_CAST(&Alarm_Clock_ASet_min_d2))
                display_set_cursor(CLOCK_SETTING_TIME_ROW,CLOCK_SETTING_TIME_MIN_D2_COL);
            else if( QHsm_state(me) == Q_STATE_CAST(&Alarm_Clock_ASet_sec_d1))
                display_set_cursor(CLOCK_SETTING_TIME_ROW,CLOCK_SETTING_TIME_SEC_D1_COL);
            else if( QHsm_state(me) == Q_STATE_CAST(&Alarm_Clock_ASet_sec_d2))
                display_set_cursor(CLOCK_SETTING_TIME_ROW,CLOCK_SETTING_TIME_SEC_D2_COL);
            else if( QHsm_state(me) == Q_STATE_CAST(&Alarm_Clock_ASet_format))
                display_set_cursor(CLOCK_SETTING_TIME_ROW,CLOCK_SETTING_TIME_FMT_COL);
            else if( QHsm_state(me) == Q_STATE_CAST(&Alarm_Clock_Alarm_OnOff))
                display_set_cursor(CLOCK_SETTING_TIME_ROW,ALARM_SETTING_STATUS_COL);

            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&Alarm_Clock_Setting);
            break;
        }
    }
    return status_;
}

/*${HSMs::Alarm_Clock::SM::CLOCK::Setting::Alarm_Setting::ASet_sec_d1} .....*/
static QState Alarm_Clock_ASet_sec_d1(Alarm_Clock * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*${HSMs::Alarm_Clock::SM::CLOCK::Setting::Alarm_Setting::ASet_sec_d1} */
        case Q_ENTRY_SIG: {
            display_set_cursor(CLOCK_SETTING_TIME_ROW, CLOCK_SETTING_TIME_SEC_D1_COL);
            me->temp_digit = DIGIT1(GET_SEC(me->temp_time));
            status_ = Q_HANDLED();
            break;
        }
        /*${HSMs::Alarm_Clock::SM::CLOCK::Setting::Alarm_Setting::ASet_sec_d1::SET} */
        case SET_SIG: {
            ++me->temp_digit; //Every time pressed button SET, it will increment the digit
            me->temp_digit %= 6; //This digit can be 0,1,2,3,4,5 .
            me->temp_time -=  DIGIT1(GET_SEC(me->temp_time)) * 10UL * 3600UL; // Updating temporary time, 10th place and milisec
            me->temp_time +=  me->temp_digit * 10UL  * 3600UL; // Updating temporary time, 10th place and milisec
            Alarm_Clock_display_clock_setting_time(me,CLOCK_SETTING_TIME_ROW,CLOCK_SETTING_TIME_COL); // Display the time as string in LCD
            display_set_cursor(CLOCK_SETTING_TIME_ROW,CLOCK_SETTING_TIME_SEC_D1_COL); // Updating Cursor bring back to second D1 place
            status_ = Q_HANDLED();
            break;
        }
        /*${HSMs::Alarm_Clock::SM::CLOCK::Setting::Alarm_Setting::ASet_sec_d1::OK} */
        case OK_SIG: {
            status_ = Q_TRAN(&Alarm_Clock_ASet_sec_d2);
            break;
        }
        default: {
            status_ = Q_SUPER(&Alarm_Clock_Alarm_Setting);
            break;
        }
    }
    return status_;
}

/*${HSMs::Alarm_Clock::SM::CLOCK::Setting::Alarm_Setting::ASet_hour_d1} ....*/
static QState Alarm_Clock_ASet_hour_d1(Alarm_Clock * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*${HSMs::Alarm_Clock::SM::CLOCK::Setting::Alarm_Setting::ASet_hour_d1} */
        case Q_ENTRY_SIG: {
            display_set_cursor(CLOCK_SETTING_TIME_ROW, CLOCK_SETTING_TIME_HOUR_D1_COL);
            me->temp_digit = DIGIT1(GET_HOUR(me->temp_time));
            status_ = Q_HANDLED();
            break;
        }
        /*${HSMs::Alarm_Clock::SM::CLOCK::Setting::Alarm_Setting::ASet_hour_d1::SET} */
        case SET_SIG: {
            ++me->temp_digit; //Every time pressed button SET, it will increment the digit
            me->temp_digit %= 3; //This digit can be 0,1 or 2.
            me->temp_time -=  DIGIT1(GET_HOUR(me->temp_time)) * 10UL * 3600UL; // Updating temporary time, 10th place and milisec
            me->temp_time +=  me->temp_digit * 10UL  * 3600UL; // Updating temporary time, 10th place and milisec
            Alarm_Clock_display_clock_setting_time(me,CLOCK_SETTING_TIME_ROW,CLOCK_SETTING_TIME_COL); // Display the time as string in LCD
            display_set_cursor(CLOCK_SETTING_TIME_ROW,CLOCK_SETTING_TIME_HOUR_D1_COL); // Updating Cursor bring back to hour D1 place
            status_ = Q_HANDLED();
            break;
        }
        /*${HSMs::Alarm_Clock::SM::CLOCK::Setting::Alarm_Setting::ASet_hour_d1::OK} */
        case OK_SIG: {
            status_ = Q_TRAN(&Alarm_Clock_ASet_hour_d2);
            break;
        }
        default: {
            status_ = Q_SUPER(&Alarm_Clock_Alarm_Setting);
            break;
        }
    }
    return status_;
}

/*${HSMs::Alarm_Clock::SM::CLOCK::Setting::Alarm_Setting::ASet_sec_d2} .....*/
static QState Alarm_Clock_ASet_sec_d2(Alarm_Clock * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*${HSMs::Alarm_Clock::SM::CLOCK::Setting::Alarm_Setting::ASet_sec_d2} */
        case Q_ENTRY_SIG: {
            display_set_cursor(CLOCK_SETTING_TIME_ROW, CLOCK_SETTING_TIME_SEC_D2_COL);
            me->temp_digit = DIGIT2(GET_SEC(me->temp_time));
            status_ = Q_HANDLED();
            break;
        }
        /*${HSMs::Alarm_Clock::SM::CLOCK::Setting::Alarm_Setting::ASet_sec_d2::SET} */
        case SET_SIG: {
            ++me->temp_digit; //Every time pressed button SET, it will increment the digit
            me->temp_digit %= 10; //This digit can be 0,1,2,3 ..... 9.
            me->temp_time -=  DIGIT2(GET_SEC(me->temp_time)) * 3600UL; // Updating temporary time, 1st place and milisec
            me->temp_time +=  me->temp_digit * 3600UL; // Updating temporary time, 1st place and milisec
            Alarm_Clock_display_clock_setting_time(me,CLOCK_SETTING_TIME_ROW,CLOCK_SETTING_TIME_COL); // Display the time as string in LCD
            display_set_cursor(CLOCK_SETTING_TIME_ROW,CLOCK_SETTING_TIME_SEC_D2_COL); // Updating Cursor bring back to second D2 place
            status_ = Q_HANDLED();
            break;
        }
        /*${HSMs::Alarm_Clock::SM::CLOCK::Setting::Alarm_Setting::ASet_sec_d2::OK} */
        case OK_SIG: {
            status_ = Q_TRAN(&Alarm_Clock_ASet_format);
            break;
        }
        default: {
            status_ = Q_SUPER(&Alarm_Clock_Alarm_Setting);
            break;
        }
    }
    return status_;
}

/*${HSMs::Alarm_Clock::SM::CLOCK::Setting::Alarm_Setting::ASet_error} ......*/
static QState Alarm_Clock_ASet_error(Alarm_Clock * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*${HSMs::Alarm_Clock::SM::CLOCK::Setting::Alarm_Setting::ASet_error} */
        case Q_ENTRY_SIG: {
            display_cursor_off_blinkoff();
            display_erase_block(1,0,15);
            me->timeout = 0;
            status_ = Q_HANDLED();
            break;
        }
        /*${HSMs::Alarm_Clock::SM::CLOCK::Setting::Alarm_Setting::ASet_error} */
        case Q_EXIT_SIG: {
            display_erase_block(CLOCK_SETTING_ERR_MSG_ROW, CLOCK_SETTING_ERR_MSG_COL,CLOCK_SETTING_ERR_MSG_COL_END);
            me->timeout = 0;
            status_ = Q_HANDLED();
            break;
        }
        /*${HSMs::Alarm_Clock::SM::CLOCK::Setting::Alarm_Setting::ASet_error::initial} */
        case Q_INIT_SIG: {
            status_ = Q_TRAN(&Alarm_Clock_AS_err_on);
            break;
        }
        /*${HSMs::Alarm_Clock::SM::CLOCK::Setting::Alarm_Setting::ASet_error::SET} */
        case SET_SIG: {
            display_cursor_on_blinkon();
            status_ = Q_TRAN(&Alarm_Clock_Alarm_Setting);
            break;
        }
        /*${HSMs::Alarm_Clock::SM::CLOCK::Setting::Alarm_Setting::ASet_error::OK} */
        case OK_SIG: {
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&Alarm_Clock_Alarm_Setting);
            break;
        }
    }
    return status_;
}

/*${HSMs::Alarm_Clock::SM::CLOCK::Setting::Alarm_Setting::ASet_error::AS_err_on}*/
static QState Alarm_Clock_AS_err_on(Alarm_Clock * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*${HSMs::Alarm_Clock::SM::CLOCK::Setting::Alarm_Setting::ASet_error::AS_err_on} */
        case Q_ENTRY_SIG: {
            display_write("Error!",CLOCK_SETTING_ERR_MSG_ROW,CLOCK_SETTING_ERR_MSG_COL );
            status_ = Q_HANDLED();
            break;
        }
        /*${HSMs::Alarm_Clock::SM::CLOCK::Setting::Alarm_Setting::ASet_error::AS_err_on::TICK} */
        case TICK_SIG: {
            ++me->timeout;
            /*${HSMs::Alarm_Clock::SM::CLOCK::Setting::Alarm_Setting::ASet_error::AS_err_on::TICK::[me->timeout==10]} */
            if (me->timeout == 10) {
                me->timeout = 0;
                status_ = Q_TRAN(&Alarm_Clock_AS_err_off);
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&Alarm_Clock_ASet_error);
            break;
        }
    }
    return status_;
}

/*${HSMs::Alarm_Clock::SM::CLOCK::Setting::Alarm_Setting::ASet_error::AS_err_off}*/
static QState Alarm_Clock_AS_err_off(Alarm_Clock * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*${HSMs::Alarm_Clock::SM::CLOCK::Setting::Alarm_Setting::ASet_error::AS_err_off} */
        case Q_ENTRY_SIG: {
            display_erase_block(CLOCK_SETTING_ERR_MSG_ROW, CLOCK_SETTING_ERR_MSG_COL,CLOCK_SETTING_ERR_MSG_COL_END);
            status_ = Q_HANDLED();
            break;
        }
        /*${HSMs::Alarm_Clock::SM::CLOCK::Setting::Alarm_Setting::ASet_error::AS_err_off::TICK} */
        case TICK_SIG: {
            ++me->timeout;
            /*${HSMs::Alarm_Clock::SM::CLOCK::Setting::Alarm_Setting::ASet_error::AS_err_off::TICK::[me->timeout==10]} */
            if (me->timeout == 10) {
                me->timeout = 0;
                status_ = Q_TRAN(&Alarm_Clock_AS_err_on);
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&Alarm_Clock_ASet_error);
            break;
        }
    }
    return status_;
}

/*${HSMs::Alarm_Clock::SM::CLOCK::Setting::Alarm_Setting::ASet_format} .....*/
static QState Alarm_Clock_ASet_format(Alarm_Clock * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*${HSMs::Alarm_Clock::SM::CLOCK::Setting::Alarm_Setting::ASet_format} */
        case Q_ENTRY_SIG: {
            display_set_cursor(CLOCK_SETTING_TIME_ROW,CLOCK_SETTING_TIME_FMT_COL); //Setting cursor at the format place
            String msg[3] = {"24H","AM ","PM "}; //Local string array that holds the format variables.
            display_write(msg[me->temp_format],CLOCK_SETTING_TIME_ROW,CLOCK_SETTING_TIME_FMT_COL); //Display the current format to LCD
            display_set_cursor(CLOCK_SETTING_TIME_ROW,CLOCK_SETTING_TIME_FMT_COL);
            status_ = Q_HANDLED();
            break;
        }
        /*${HSMs::Alarm_Clock::SM::CLOCK::Setting::Alarm_Setting::ASet_format::SET} */
        case SET_SIG: {
            String msg;
            if(me->temp_format == FORMAT_24H){
                me->temp_format = FORMAT_AM;
                msg = "AM ";
            }
            else if(me->temp_format == FORMAT_AM){
                me->temp_format = FORMAT_PM;
                msg = "PM ";
            }
            else if (me->temp_format == FORMAT_PM){
                me->temp_format = FORMAT_24H;
                msg = "24H";
            }
            display_write(msg,CLOCK_SETTING_TIME_ROW,CLOCK_SETTING_TIME_FMT_COL);
            display_set_cursor(CLOCK_SETTING_TIME_ROW,CLOCK_SETTING_TIME_FMT_COL);
            status_ = Q_HANDLED();
            break;
        }
        /*${HSMs::Alarm_Clock::SM::CLOCK::Setting::Alarm_Setting::ASet_format::OK} */
        case OK_SIG: {
            /*${HSMs::Alarm_Clock::SM::CLOCK::Setting::Alarm_Setting::ASet_format::OK::[is_time_set_error(me->temp_time~} */
            if (is_time_set_error(me->temp_time, (time_format_t)me->temp_format)) {
                status_ = Q_TRAN(&Alarm_Clock_ASet_error);
            }
            /*${HSMs::Alarm_Clock::SM::CLOCK::Setting::Alarm_Setting::ASet_format::OK::[else]} */
            else {
                status_ = Q_TRAN(&Alarm_Clock_Alarm_OnOff);
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&Alarm_Clock_Alarm_Setting);
            break;
        }
    }
    return status_;
}

/*${HSMs::Alarm_Clock::SM::CLOCK::Setting::Alarm_Setting::ASet_hour_d2} ....*/
static QState Alarm_Clock_ASet_hour_d2(Alarm_Clock * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*${HSMs::Alarm_Clock::SM::CLOCK::Setting::Alarm_Setting::ASet_hour_d2} */
        case Q_ENTRY_SIG: {
            display_set_cursor(CLOCK_SETTING_TIME_ROW, CLOCK_SETTING_TIME_HOUR_D2_COL);
            me->temp_digit = DIGIT2(GET_HOUR(me->temp_time));
            status_ = Q_HANDLED();
            break;
        }
        /*${HSMs::Alarm_Clock::SM::CLOCK::Setting::Alarm_Setting::ASet_hour_d2::SET} */
        case SET_SIG: {
            ++me->temp_digit; //Every time pressed button SET, it will increment the digit
            me->temp_digit %= 10; //This digit can be 0,1,2,3 ..... 9.
            me->temp_time -=  DIGIT2(GET_HOUR(me->temp_time)) * 3600UL; // Updating temporary time, 1st place and milisec
            me->temp_time +=  me->temp_digit * 3600UL; // Updating temporary time, 1st place and milisec
            Alarm_Clock_display_clock_setting_time(me,CLOCK_SETTING_TIME_ROW,CLOCK_SETTING_TIME_COL); // Display the time as string in LCD
            display_set_cursor(CLOCK_SETTING_TIME_ROW,CLOCK_SETTING_TIME_HOUR_D2_COL); // Updating Cursor bring back to hour D1 place
            status_ = Q_HANDLED();
            break;
        }
        /*${HSMs::Alarm_Clock::SM::CLOCK::Setting::Alarm_Setting::ASet_hour_d2::OK} */
        case OK_SIG: {
            status_ = Q_TRAN(&Alarm_Clock_ASet_min_d1);
            break;
        }
        default: {
            status_ = Q_SUPER(&Alarm_Clock_Alarm_Setting);
            break;
        }
    }
    return status_;
}

/*${HSMs::Alarm_Clock::SM::CLOCK::Setting::Alarm_Setting::ASet_min_d1} .....*/
static QState Alarm_Clock_ASet_min_d1(Alarm_Clock * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*${HSMs::Alarm_Clock::SM::CLOCK::Setting::Alarm_Setting::ASet_min_d1} */
        case Q_ENTRY_SIG: {
            display_set_cursor(CLOCK_SETTING_TIME_ROW, CLOCK_SETTING_TIME_MIN_D1_COL);
            me->temp_digit = DIGIT1(GET_MIN(me->temp_time));
            status_ = Q_HANDLED();
            break;
        }
        /*${HSMs::Alarm_Clock::SM::CLOCK::Setting::Alarm_Setting::ASet_min_d1::SET} */
        case SET_SIG: {
            ++me->temp_digit; //Every time pressed button SET, it will increment the digit
            me->temp_digit %= 6; //This digit can be 0,1,2,3,4,5 .
            me->temp_time -=  DIGIT1(GET_MIN(me->temp_time)) * 10UL * 3600UL; // Updating temporary time, 10th place and milisec
            me->temp_time +=  me->temp_digit * 10UL  * 3600UL; // Updating temporary time, 10th place and milisec
            Alarm_Clock_display_clock_setting_time(me,CLOCK_SETTING_TIME_ROW,CLOCK_SETTING_TIME_COL); // Display the time as string in LCD
            display_set_cursor(CLOCK_SETTING_TIME_ROW,CLOCK_SETTING_TIME_MIN_D1_COL); // Updating Cursor bring back to minute D1 place
            status_ = Q_HANDLED();
            break;
        }
        /*${HSMs::Alarm_Clock::SM::CLOCK::Setting::Alarm_Setting::ASet_min_d1::OK} */
        case OK_SIG: {
            status_ = Q_TRAN(&Alarm_Clock_ASet_min_d2);
            break;
        }
        default: {
            status_ = Q_SUPER(&Alarm_Clock_Alarm_Setting);
            break;
        }
    }
    return status_;
}

/*${HSMs::Alarm_Clock::SM::CLOCK::Setting::Alarm_Setting::ASet_min_d2} .....*/
static QState Alarm_Clock_ASet_min_d2(Alarm_Clock * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*${HSMs::Alarm_Clock::SM::CLOCK::Setting::Alarm_Setting::ASet_min_d2} */
        case Q_ENTRY_SIG: {
            display_set_cursor(CLOCK_SETTING_TIME_ROW, CLOCK_SETTING_TIME_MIN_D2_COL);
            me->temp_digit = DIGIT2(GET_MIN(me->temp_time));
            status_ = Q_HANDLED();
            break;
        }
        /*${HSMs::Alarm_Clock::SM::CLOCK::Setting::Alarm_Setting::ASet_min_d2::SET} */
        case SET_SIG: {
            ++me->temp_digit; //Every time pressed button SET, it will increment the digit
            me->temp_digit %= 10; //This digit can be 0,1,2,3 ..... 9.
            me->temp_time -=  DIGIT2(GET_MIN(me->temp_time)) * 3600UL; // Updating temporary time, 1st place and milisec
            me->temp_time +=  me->temp_digit * 3600UL; // Updating temporary time, 1st place and milisec
            Alarm_Clock_display_clock_setting_time(me,CLOCK_SETTING_TIME_ROW,CLOCK_SETTING_TIME_COL); // Display the time as string in LCD
            display_set_cursor(CLOCK_SETTING_TIME_ROW,CLOCK_SETTING_TIME_MIN_D2_COL); // Updating Cursor bring back to minute D2 place
            status_ = Q_HANDLED();
            break;
        }
        /*${HSMs::Alarm_Clock::SM::CLOCK::Setting::Alarm_Setting::ASet_min_d2::OK} */
        case OK_SIG: {
            status_ = Q_TRAN(&Alarm_Clock_ASet_sec_d1);
            break;
        }
        default: {
            status_ = Q_SUPER(&Alarm_Clock_Alarm_Setting);
            break;
        }
    }
    return status_;
}

/*${HSMs::Alarm_Clock::SM::CLOCK::Setting::Alarm_Setting::Alarm_OnOff} .....*/
static QState Alarm_Clock_Alarm_OnOff(Alarm_Clock * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*${HSMs::Alarm_Clock::SM::CLOCK::Setting::Alarm_Setting::Alarm_OnOff} */
        case Q_ENTRY_SIG: {
            display_erase_block(ALARM_SETTING_STATUS_ROW,0,15);
            me->temp_digit = 0U;
            display_write("ALARM OFF",ALARM_SETTING_STATUS_ROW,ALARM_SETTING_STATUS_COL);
            display_set_cursor(ALARM_SETTING_STATUS_ROW,ALARM_SETTING_STATUS_COL);
            status_ = Q_HANDLED();
            break;
        }
        /*${HSMs::Alarm_Clock::SM::CLOCK::Setting::Alarm_Setting::Alarm_OnOff::SET} */
        case SET_SIG: {
            if(me->temp_digit){
                display_write("ALARM OFF",ALARM_SETTING_STATUS_ROW,ALARM_SETTING_STATUS_COL);
                me->temp_digit = 0;
            }else{
                display_write("ALARM ON ",ALARM_SETTING_STATUS_ROW,ALARM_SETTING_STATUS_COL);
                me->temp_digit = 1;
            }
            display_set_cursor(ALARM_SETTING_STATUS_ROW,ALARM_SETTING_STATUS_COL);
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&Alarm_Clock_Alarm_Setting);
            break;
        }
    }
    return status_;
}

/*${HSMs::Alarm_Clock::SM::CLOCK::Setting::Clock_Setting} ..................*/
static QState Alarm_Clock_Clock_Setting(Alarm_Clock * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*${HSMs::Alarm_Clock::SM::CLOCK::Setting::Clock_Setting} */
        case Q_ENTRY_SIG: {
            Alarm_Clock_display_clock_setting_time(me, CLOCK_SETTING_TIME_ROW, CLOCK_SETTING_TIME_COL);
            display_cursor_on_blinkon();
            status_ = Q_HANDLED();
            break;
        }
        /*${HSMs::Alarm_Clock::SM::CLOCK::Setting::Clock_Setting::initial} */
        case Q_INIT_SIG: {
            status_ = Q_TRAN(&Alarm_Clock_ClkSet_hour_d1);
            break;
        }
        /*${HSMs::Alarm_Clock::SM::CLOCK::Setting::Clock_Setting::OK} */
        case OK_SIG: {
            if(me->temp_format != FORMAT_24H){
                me->temp_time = convert_12hformat_to_24h( me->temp_time,(time_format_t)me->temp_format);
                me->time_mode = MODE_12H;
            }else{
                me->time_mode = MODE_24H;
            }
            me->temp_time *= 10UL; //converting temp_time to number of 100 milisecond format
            Alarm_Clock_set_curr_time(me->temp_time); //This is the operation
            /*${HSMs::Alarm_Clock::SM::CLOCK::Setting::Clock_Setting::OK::[0]} */
            if (0) {
                status_ = Q_HANDLED();
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&Alarm_Clock_Setting);
            break;
        }
    }
    return status_;
}

/*${HSMs::Alarm_Clock::SM::CLOCK::Setting::Clock_Setting::ClkSet_hour_d2} ..*/
static QState Alarm_Clock_ClkSet_hour_d2(Alarm_Clock * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*${HSMs::Alarm_Clock::SM::CLOCK::Setting::Clock_Setting::ClkSet_hour_d2} */
        case Q_ENTRY_SIG: {
            display_set_cursor(CLOCK_SETTING_TIME_ROW, CLOCK_SETTING_TIME_HOUR_D2_COL);
            me->temp_digit = DIGIT2(GET_HOUR(me->temp_time));
            status_ = Q_HANDLED();
            break;
        }
        /*${HSMs::Alarm_Clock::SM::CLOCK::Setting::Clock_Setting::ClkSet_hour_d2::SET} */
        case SET_SIG: {
            ++me->temp_digit; //Every time pressed button SET, it will increment the digit
            me->temp_digit %= 10; //This digit can be 0,1,2,3 ..... 9.
            me->temp_time -=  DIGIT2(GET_HOUR(me->temp_time)) * 3600UL; // Updating temporary time, 1st place and milisec
            me->temp_time +=  me->temp_digit * 3600UL; // Updating temporary time, 1st place and milisec
            Alarm_Clock_display_clock_setting_time(me,CLOCK_SETTING_TIME_ROW,CLOCK_SETTING_TIME_COL); // Display the time as string in LCD
            display_set_cursor(CLOCK_SETTING_TIME_ROW,CLOCK_SETTING_TIME_HOUR_D2_COL); // Updating Cursor bring back to hour D1 place
            status_ = Q_HANDLED();
            break;
        }
        /*${HSMs::Alarm_Clock::SM::CLOCK::Setting::Clock_Setting::ClkSet_hour_d2::OK} */
        case OK_SIG: {
            status_ = Q_TRAN(&Alarm_Clock_ClkSet_min_d1);
            break;
        }
        default: {
            status_ = Q_SUPER(&Alarm_Clock_Clock_Setting);
            break;
        }
    }
    return status_;
}

/*${HSMs::Alarm_Clock::SM::CLOCK::Setting::Clock_Setting::ClkSet_min_d2} ...*/
static QState Alarm_Clock_ClkSet_min_d2(Alarm_Clock * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*${HSMs::Alarm_Clock::SM::CLOCK::Setting::Clock_Setting::ClkSet_min_d2} */
        case Q_ENTRY_SIG: {
            display_set_cursor(CLOCK_SETTING_TIME_ROW, CLOCK_SETTING_TIME_MIN_D2_COL);
            me->temp_digit = DIGIT2(GET_MIN(me->temp_time));
            status_ = Q_HANDLED();
            break;
        }
        /*${HSMs::Alarm_Clock::SM::CLOCK::Setting::Clock_Setting::ClkSet_min_d2::SET} */
        case SET_SIG: {
            ++me->temp_digit; //Every time pressed button SET, it will increment the digit
            me->temp_digit %= 10; //This digit can be 0,1,2,3 ..... 9.
            me->temp_time -=  DIGIT2(GET_MIN(me->temp_time)) * 3600UL; // Updating temporary time, 1st place and milisec
            me->temp_time +=  me->temp_digit * 3600UL; // Updating temporary time, 1st place and milisec
            Alarm_Clock_display_clock_setting_time(me,CLOCK_SETTING_TIME_ROW,CLOCK_SETTING_TIME_COL); // Display the time as string in LCD
            display_set_cursor(CLOCK_SETTING_TIME_ROW,CLOCK_SETTING_TIME_MIN_D2_COL); // Updating Cursor bring back to minute D2 place
            status_ = Q_HANDLED();
            break;
        }
        /*${HSMs::Alarm_Clock::SM::CLOCK::Setting::Clock_Setting::ClkSet_min_d2::OK} */
        case OK_SIG: {
            status_ = Q_TRAN(&Alarm_Clock_ClkSet_sec_d1);
            break;
        }
        default: {
            status_ = Q_SUPER(&Alarm_Clock_Clock_Setting);
            break;
        }
    }
    return status_;
}

/*${HSMs::Alarm_Clock::SM::CLOCK::Setting::Clock_Setting::ClkSet_format} ...*/
static QState Alarm_Clock_ClkSet_format(Alarm_Clock * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*${HSMs::Alarm_Clock::SM::CLOCK::Setting::Clock_Setting::ClkSet_format} */
        case Q_ENTRY_SIG: {
            display_set_cursor(CLOCK_SETTING_TIME_ROW,CLOCK_SETTING_TIME_FMT_COL); //Setting cursor at the format place
            String msg[3] = {"24H","AM ","PM "}; //Local string array that holds the format variables.
            display_write(msg[me->temp_format],CLOCK_SETTING_TIME_ROW,CLOCK_SETTING_TIME_FMT_COL); //Display the current format to LCD
            display_set_cursor(CLOCK_SETTING_TIME_ROW,CLOCK_SETTING_TIME_FMT_COL);
            status_ = Q_HANDLED();
            break;
        }
        /*${HSMs::Alarm_Clock::SM::CLOCK::Setting::Clock_Setting::ClkSet_format::SET} */
        case SET_SIG: {
            String msg;
            if(me->temp_format == FORMAT_24H){
                me->temp_format = FORMAT_AM;
                msg = "AM ";
            }
            else if(me->temp_format == FORMAT_AM){
                me->temp_format = FORMAT_PM;
                msg = "PM ";
            }
            else if (me->temp_format == FORMAT_PM){
                me->temp_format = FORMAT_24H;
                msg = "24H";
            }
            display_write(msg,CLOCK_SETTING_TIME_ROW,CLOCK_SETTING_TIME_FMT_COL);
            display_set_cursor(CLOCK_SETTING_TIME_ROW,CLOCK_SETTING_TIME_FMT_COL);
            status_ = Q_HANDLED();
            break;
        }
        /*${HSMs::Alarm_Clock::SM::CLOCK::Setting::Clock_Setting::ClkSet_format::OK} */
        case OK_SIG: {
            /*${HSMs::Alarm_Clock::SM::CLOCK::Setting::Clock_Setting::ClkSet_format::OK::[is_time_set_error(me->temp_time~} */
            if (is_time_set_error(me->temp_time, (time_format_t)me->temp_format)) {
                status_ = Q_TRAN(&Alarm_Clock_ClkSet_error);
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&Alarm_Clock_Clock_Setting);
            break;
        }
    }
    return status_;
}

/*${HSMs::Alarm_Clock::SM::CLOCK::Setting::Clock_Setting::ClkSet_sec_d2} ...*/
static QState Alarm_Clock_ClkSet_sec_d2(Alarm_Clock * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*${HSMs::Alarm_Clock::SM::CLOCK::Setting::Clock_Setting::ClkSet_sec_d2} */
        case Q_ENTRY_SIG: {
            display_set_cursor(CLOCK_SETTING_TIME_ROW, CLOCK_SETTING_TIME_SEC_D2_COL);
            me->temp_digit = DIGIT2(GET_SEC(me->temp_time));
            status_ = Q_HANDLED();
            break;
        }
        /*${HSMs::Alarm_Clock::SM::CLOCK::Setting::Clock_Setting::ClkSet_sec_d2::SET} */
        case SET_SIG: {
            ++me->temp_digit; //Every time pressed button SET, it will increment the digit
            me->temp_digit %= 10; //This digit can be 0,1,2,3 ..... 9.
            me->temp_time -=  DIGIT2(GET_SEC(me->temp_time)) * 3600UL; // Updating temporary time, 1st place and milisec
            me->temp_time +=  me->temp_digit * 3600UL; // Updating temporary time, 1st place and milisec
            Alarm_Clock_display_clock_setting_time(me,CLOCK_SETTING_TIME_ROW,CLOCK_SETTING_TIME_COL); // Display the time as string in LCD
            display_set_cursor(CLOCK_SETTING_TIME_ROW,CLOCK_SETTING_TIME_SEC_D2_COL); // Updating Cursor bring back to second D2 place
            status_ = Q_HANDLED();
            break;
        }
        /*${HSMs::Alarm_Clock::SM::CLOCK::Setting::Clock_Setting::ClkSet_sec_d2::OK} */
        case OK_SIG: {
            status_ = Q_TRAN(&Alarm_Clock_ClkSet_format);
            break;
        }
        default: {
            status_ = Q_SUPER(&Alarm_Clock_Clock_Setting);
            break;
        }
    }
    return status_;
}

/*${HSMs::Alarm_Clock::SM::CLOCK::Setting::Clock_Setting::ClkSet_hour_d1} ..*/
static QState Alarm_Clock_ClkSet_hour_d1(Alarm_Clock * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*${HSMs::Alarm_Clock::SM::CLOCK::Setting::Clock_Setting::ClkSet_hour_d1} */
        case Q_ENTRY_SIG: {
            display_set_cursor(CLOCK_SETTING_TIME_ROW, CLOCK_SETTING_TIME_HOUR_D1_COL);
            me->temp_digit = DIGIT1(GET_HOUR(me->temp_time));
            status_ = Q_HANDLED();
            break;
        }
        /*${HSMs::Alarm_Clock::SM::CLOCK::Setting::Clock_Setting::ClkSet_hour_d1::SET} */
        case SET_SIG: {
            ++me->temp_digit; //Every time pressed button SET, it will increment the digit
            me->temp_digit %= 3; //This digit can be 0,1 or 2.
            me->temp_time -=  DIGIT1(GET_HOUR(me->temp_time)) * 10UL * 3600UL; // Updating temporary time, 10th place and milisec
            me->temp_time +=  me->temp_digit * 10UL  * 3600UL; // Updating temporary time, 10th place and milisec
            Alarm_Clock_display_clock_setting_time(me,CLOCK_SETTING_TIME_ROW,CLOCK_SETTING_TIME_COL); // Display the time as string in LCD
            display_set_cursor(CLOCK_SETTING_TIME_ROW,CLOCK_SETTING_TIME_HOUR_D1_COL); // Updating Cursor bring back to hour D1 place
            status_ = Q_HANDLED();
            break;
        }
        /*${HSMs::Alarm_Clock::SM::CLOCK::Setting::Clock_Setting::ClkSet_hour_d1::OK} */
        case OK_SIG: {
            status_ = Q_TRAN(&Alarm_Clock_ClkSet_hour_d2);
            break;
        }
        default: {
            status_ = Q_SUPER(&Alarm_Clock_Clock_Setting);
            break;
        }
    }
    return status_;
}

/*${HSMs::Alarm_Clock::SM::CLOCK::Setting::Clock_Setting::ClkSet_min_d1} ...*/
static QState Alarm_Clock_ClkSet_min_d1(Alarm_Clock * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*${HSMs::Alarm_Clock::SM::CLOCK::Setting::Clock_Setting::ClkSet_min_d1} */
        case Q_ENTRY_SIG: {
            display_set_cursor(CLOCK_SETTING_TIME_ROW, CLOCK_SETTING_TIME_MIN_D1_COL);
            me->temp_digit = DIGIT1(GET_MIN(me->temp_time));
            status_ = Q_HANDLED();
            break;
        }
        /*${HSMs::Alarm_Clock::SM::CLOCK::Setting::Clock_Setting::ClkSet_min_d1::SET} */
        case SET_SIG: {
            ++me->temp_digit; //Every time pressed button SET, it will increment the digit
            me->temp_digit %= 6; //This digit can be 0,1,2,3,4,5 .
            me->temp_time -=  DIGIT1(GET_MIN(me->temp_time)) * 10UL * 3600UL; // Updating temporary time, 10th place and milisec
            me->temp_time +=  me->temp_digit * 10UL  * 3600UL; // Updating temporary time, 10th place and milisec
            Alarm_Clock_display_clock_setting_time(me,CLOCK_SETTING_TIME_ROW,CLOCK_SETTING_TIME_COL); // Display the time as string in LCD
            display_set_cursor(CLOCK_SETTING_TIME_ROW,CLOCK_SETTING_TIME_MIN_D1_COL); // Updating Cursor bring back to minute D1 place
            status_ = Q_HANDLED();
            break;
        }
        /*${HSMs::Alarm_Clock::SM::CLOCK::Setting::Clock_Setting::ClkSet_min_d1::OK} */
        case OK_SIG: {
            status_ = Q_TRAN(&Alarm_Clock_ClkSet_min_d2);
            break;
        }
        default: {
            status_ = Q_SUPER(&Alarm_Clock_Clock_Setting);
            break;
        }
    }
    return status_;
}

/*${HSMs::Alarm_Clock::SM::CLOCK::Setting::Clock_Setting::ClkSet_error} ....*/
static QState Alarm_Clock_ClkSet_error(Alarm_Clock * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*${HSMs::Alarm_Clock::SM::CLOCK::Setting::Clock_Setting::ClkSet_error} */
        case Q_ENTRY_SIG: {
            display_cursor_off_blinkoff();
            status_ = Q_HANDLED();
            break;
        }
        /*${HSMs::Alarm_Clock::SM::CLOCK::Setting::Clock_Setting::ClkSet_error} */
        case Q_EXIT_SIG: {
            display_erase_block(CLOCK_SETTING_ERR_MSG_ROW, CLOCK_SETTING_ERR_MSG_COL,CLOCK_SETTING_ERR_MSG_COL_END);
            me->timeout = 0;
            status_ = Q_HANDLED();
            break;
        }
        /*${HSMs::Alarm_Clock::SM::CLOCK::Setting::Clock_Setting::ClkSet_error::initial} */
        case Q_INIT_SIG: {
            status_ = Q_TRAN(&Alarm_Clock_err_on);
            break;
        }
        /*${HSMs::Alarm_Clock::SM::CLOCK::Setting::Clock_Setting::ClkSet_error::SET} */
        case SET_SIG: {
            display_cursor_on_blinkon();
            status_ = Q_TRAN(&Alarm_Clock_Clock_Setting);
            break;
        }
        /*${HSMs::Alarm_Clock::SM::CLOCK::Setting::Clock_Setting::ClkSet_error::OK} */
        case OK_SIG: {
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&Alarm_Clock_Clock_Setting);
            break;
        }
    }
    return status_;
}

/*${HSMs::Alarm_Clock::SM::CLOCK::Setting::Clock_Setting::ClkSet_error::err_on}*/
static QState Alarm_Clock_err_on(Alarm_Clock * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*${HSMs::Alarm_Clock::SM::CLOCK::Setting::Clock_Setting::ClkSet_error::err_on} */
        case Q_ENTRY_SIG: {
            display_write("Error!",CLOCK_SETTING_ERR_MSG_ROW,CLOCK_SETTING_ERR_MSG_COL );
            status_ = Q_HANDLED();
            break;
        }
        /*${HSMs::Alarm_Clock::SM::CLOCK::Setting::Clock_Setting::ClkSet_error::err_on::TICK} */
        case TICK_SIG: {
            ++me->timeout;
            /*${HSMs::Alarm_Clock::SM::CLOCK::Setting::Clock_Setting::ClkSet_error::err_on::TICK::[me->timeout==10]} */
            if (me->timeout == 10) {
                me->timeout = 0;
                status_ = Q_TRAN(&Alarm_Clock_err_off);
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&Alarm_Clock_ClkSet_error);
            break;
        }
    }
    return status_;
}

/*${HSMs::Alarm_Clock::SM::CLOCK::Setting::Clock_Setting::ClkSet_error::err_off}*/
static QState Alarm_Clock_err_off(Alarm_Clock * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*${HSMs::Alarm_Clock::SM::CLOCK::Setting::Clock_Setting::ClkSet_error::err_off} */
        case Q_ENTRY_SIG: {
            display_erase_block(CLOCK_SETTING_ERR_MSG_ROW, CLOCK_SETTING_ERR_MSG_COL,CLOCK_SETTING_ERR_MSG_COL_END);
            status_ = Q_HANDLED();
            break;
        }
        /*${HSMs::Alarm_Clock::SM::CLOCK::Setting::Clock_Setting::ClkSet_error::err_off::TICK} */
        case TICK_SIG: {
            ++me->timeout;
            /*${HSMs::Alarm_Clock::SM::CLOCK::Setting::Clock_Setting::ClkSet_error::err_off::TICK::[me->timeout==10]} */
            if (me->timeout == 10) {
                me->timeout = 0;
                status_ = Q_TRAN(&Alarm_Clock_err_on);
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&Alarm_Clock_ClkSet_error);
            break;
        }
    }
    return status_;
}

/*${HSMs::Alarm_Clock::SM::CLOCK::Setting::Clock_Setting::ClkSet_sec_d1} ...*/
static QState Alarm_Clock_ClkSet_sec_d1(Alarm_Clock * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*${HSMs::Alarm_Clock::SM::CLOCK::Setting::Clock_Setting::ClkSet_sec_d1} */
        case Q_ENTRY_SIG: {
            display_set_cursor(CLOCK_SETTING_TIME_ROW, CLOCK_SETTING_TIME_SEC_D1_COL);
            me->temp_digit = DIGIT1(GET_SEC(me->temp_time));
            status_ = Q_HANDLED();
            break;
        }
        /*${HSMs::Alarm_Clock::SM::CLOCK::Setting::Clock_Setting::ClkSet_sec_d1::SET} */
        case SET_SIG: {
            ++me->temp_digit; //Every time pressed button SET, it will increment the digit
            me->temp_digit %= 6; //This digit can be 0,1,2,3,4,5 .
            me->temp_time -=  DIGIT1(GET_SEC(me->temp_time)) * 10UL * 3600UL; // Updating temporary time, 10th place and milisec
            me->temp_time +=  me->temp_digit * 10UL  * 3600UL; // Updating temporary time, 10th place and milisec
            Alarm_Clock_display_clock_setting_time(me,CLOCK_SETTING_TIME_ROW,CLOCK_SETTING_TIME_COL); // Display the time as string in LCD
            display_set_cursor(CLOCK_SETTING_TIME_ROW,CLOCK_SETTING_TIME_SEC_D1_COL); // Updating Cursor bring back to second D1 place
            status_ = Q_HANDLED();
            break;
        }
        /*${HSMs::Alarm_Clock::SM::CLOCK::Setting::Clock_Setting::ClkSet_sec_d1::OK} */
        case OK_SIG: {
            status_ = Q_TRAN(&Alarm_Clock_ClkSet_sec_d2);
            break;
        }
        default: {
            status_ = Q_SUPER(&Alarm_Clock_Clock_Setting);
            break;
        }
    }
    return status_;
}

/*${HSMs::Alarm_Clock::SM::CLOCK::Ticking} .................................*/
static QState Alarm_Clock_Ticking(Alarm_Clock * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*${HSMs::Alarm_Clock::SM::CLOCK::Ticking} */
        case Q_ENTRY_SIG: {
            Alarm_Clock_display_curr_time(me, TICKING_CURR_TIME_ROW, TICKING_CURR_TIME_COL );
            status_ = Q_HANDLED();
            break;
        }
        /*${HSMs::Alarm_Clock::SM::CLOCK::Ticking} */
        case Q_EXIT_SIG: {
            display_clear();
            status_ = Q_HANDLED();
            break;
        }
        /*${HSMs::Alarm_Clock::SM::CLOCK::Ticking::SET} */
        case SET_SIG: {
            me->temp_time = Alarm_Clock_get_curr_time()/10;
            if(me->time_mode == MODE_12H){
                if(get_am_or_pm(me->temp_time).equals("AM")){
                    me->temp_format = FORMAT_AM;
                }
                else{
                    me->temp_format = FORMAT_PM;
                }
                me->temp_time = convert_24hformat_to_12h(me->temp_time);
            }
            else
                me->temp_format = FORMAT_24H;
            status_ = Q_TRAN(&Alarm_Clock_Clock_Setting);
            break;
        }
        /*${HSMs::Alarm_Clock::SM::CLOCK::Ticking::OK} */
        case OK_SIG: {
            status_ = Q_TRAN(&Alarm_Clock_Alarm_Setting);
            break;
        }
        /*${HSMs::Alarm_Clock::SM::CLOCK::Ticking::TICK} */
        case TICK_SIG: {
            Alarm_Clock_display_curr_time(me, TICKING_CURR_TIME_ROW, TICKING_CURR_TIME_COL );
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&Alarm_Clock_CLOCK);
            break;
        }
    }
    return status_;
}

/*${HSMs::Alarm_Clock::SM::Alarm_Reminder} .................................*/
static QState Alarm_Clock_Alarm_Reminder(Alarm_Clock * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*${HSMs::Alarm_Clock::SM::Alarm_Reminder} */
        case Q_ENTRY_SIG: {
            me->timeout = 0;
            status_ = Q_HANDLED();
            break;
        }
        /*${HSMs::Alarm_Clock::SM::Alarm_Reminder} */
        case Q_EXIT_SIG: {
            display_clear();
            status_ = Q_HANDLED();
            break;
        }
        /*${HSMs::Alarm_Clock::SM::Alarm_Reminder::initial} */
        case Q_INIT_SIG: {
            status_ = Q_TRAN(&Alarm_Clock_Alarm_Msg_ON);
            break;
        }
        /*${HSMs::Alarm_Clock::SM::Alarm_Reminder::OK} */
        case OK_SIG: {
            status_ = Q_TRAN_HIST(me->hist_CLOCK);
            break;
        }
        /*${HSMs::Alarm_Clock::SM::Alarm_Reminder::TICK} */
        case TICK_SIG: {
            Alarm_Clock_display_curr_time(me,ALARM_SETTING_CURR_TIME_ROW,ALARM_SETTING_CURR_TIME_COL);
            /*${HSMs::Alarm_Clock::SM::Alarm_Reminder::TICK::[++me->alarm_timeout==200]} */
            if (++me->alarm_timeout == 200) {
                me->alarm_timeout = 0;
                status_ = Q_TRAN(&Alarm_Clock_Ticking);
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

/*${HSMs::Alarm_Clock::SM::Alarm_Reminder::Alarm_Msg_ON} ...................*/
static QState Alarm_Clock_Alarm_Msg_ON(Alarm_Clock * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*${HSMs::Alarm_Clock::SM::Alarm_Reminder::Alarm_Msg_ON} */
        case Q_ENTRY_SIG: {
            display_write("*ALARM*",ALARM_REMINDER_MSG_ROW,ALARM_REMINDER_MSG_COL);
            status_ = Q_HANDLED();
            break;
        }
        /*${HSMs::Alarm_Clock::SM::Alarm_Reminder::Alarm_Msg_ON::TICK} */
        case TICK_SIG: {
            me->timeout++;
            /*${HSMs::Alarm_Clock::SM::Alarm_Reminder::Alarm_Msg_ON::TICK::[me->timeout==10]} */
            if (me->timeout == 10) {
                me->timeout = 0;
                status_ = Q_TRAN(&Alarm_Clock_Alarm_Msg_OFF);
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&Alarm_Clock_Alarm_Reminder);
            break;
        }
    }
    return status_;
}

/*${HSMs::Alarm_Clock::SM::Alarm_Reminder::Alarm_Msg_OFF} ..................*/
static QState Alarm_Clock_Alarm_Msg_OFF(Alarm_Clock * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*${HSMs::Alarm_Clock::SM::Alarm_Reminder::Alarm_Msg_OFF} */
        case Q_ENTRY_SIG: {
            display_erase_block(ALARM_REMINDER_MSG_ROW,ALARM_REMINDER_MSG_COL,10);
            status_ = Q_HANDLED();
            break;
        }
        /*${HSMs::Alarm_Clock::SM::Alarm_Reminder::Alarm_Msg_OFF::TICK} */
        case TICK_SIG: {
            me->timeout++;
            /*${HSMs::Alarm_Clock::SM::Alarm_Reminder::Alarm_Msg_OFF::TICK::[me->timeout==10]} */
            if (me->timeout == 10) {
                me->timeout = 0;
                status_ = Q_TRAN(&Alarm_Clock_Alarm_Msg_ON);
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&Alarm_Clock_Alarm_Reminder);
            break;
        }
    }
    return status_;
}
/*$enddef${HSMs::Alarm_Clock} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/




ISR(TIMER1_COMPA_vect){
    Alarm_Clock_update_curr_time();

}


/*
 * Description : Decodes AM/PM information from given time in 24H format
 * param1: Integer time in 24H format
 * return : A string value("AM" or "PM")
 */
String get_am_or_pm(uint32_t time24h){
    String ampm;
    uint8_t h = GET_HOUR(time24h);
    if(h == 0U){
        ampm = "AM";
    }else if( h > 12U){
        ampm = "PM";
    }else if (h == 12U)
        ampm = "PM";
    else
        ampm = "AM";
    return ampm;
}

/*
 * Description: Writes a message to the LCD at given row and column number
 * param1 : Message to write in 'String' format
 * param2 : row number of the LCD
 * param2 : column number of the LCD
 */
void  display_write(String str_, uint8_t r, uint8_t c){
    lcd_set_cursor(c,r);
    lcd_print_string(str_);
}

/*
 * Description: converts an 'integer' time to 'String' time
 * param1 : time represented in terms of number of seconds
 * return : time as 'String' value in the format HH:MM:SS
 */
String integertime_to_string(uint32_t time_){
    uint8_t h,m,s;
    char buf[10]; //00:00:00+null
    h = GET_HOUR(time_); /* Extract how many hours the 'time_' represent */
    m = GET_MIN(time_);  /* Extract how many minutes the 'time_' represent */
    s = GET_SEC(time_);     /* Extract how many seconds the 'time_' represent */
    sprintf(buf,"%02d:%02d:%02d",h,m,s);
    return (String)buf;
}

/*
 * Description: Converts given integer time in 12H format to integer time 24H format
 * param1 : Integer time in 12H format
 * param2 : time format of type time_format_t
 * return : Integer time in 24H format
 */
uint32_t convert_12hformat_to_24h(uint32_t time12h, time_format_t ampm){
    uint8_t hour;
    uint32_t time24h;
    hour = GET_HOUR(time12h);
    if(ampm == FORMAT_AM){
        time24h = (hour == 12)? (time12h-(12UL * 3600UL)) : time12h;
    }else{
        time24h = (hour == 12)? time12h : (time12h +(12UL * 3600UL));
    }
    return time24h;
}

/*
 * Description: Converts given integer time in 24H format to integer time 12H format
 * param1 : Integer time in 24H format
 * return : Integer time in 12H format
 */
uint32_t convert_24hformat_to_12h(uint32_t time24h){
    uint8_t hour;
    uint32_t time12h;
    hour = GET_HOUR(time24h);

    if(hour == 0)
        time12h = time24h + (12UL * 3600UL);
    else{
        if((hour < 12UL) || (hour == 12UL))
            return time24h;
        else
            time12h = time24h - (12UL * 3600UL);
    }
    return time12h;
}


void display_cursor_on_blinkon(){
    lcd_cursor_show();
    lcd_cursor_blink();
}

void display_cursor_off_blinkoff(){
    lcd_cursor_off();
    lcd_cursor_blinkoff();
}


void display_set_cursor(uint8_t r, uint8_t c){
     lcd_set_cursor(c,r);
}

void display_clear(void){
    lcd_clear();
}

//This function used in the error parts and check the time set is ok or not.
bool is_time_set_error(uint32_t time_,time_format_t format){
    uint8_t h = GET_HOUR(time_);
    return ((h > 23) || ((h > 12 || (h == 0))&& format != FORMAT_24H) );
}


//This function makes empty the desired places in the LCD
void display_erase_block(uint8_t row,uint8_t col_start,uint8_t col_stop)
{
    uint8_t len = col_stop - col_start;
    do{
        lcd_set_cursor(col_start++,row);
        lcd_print_char(' ');
    }while(len--);
}



